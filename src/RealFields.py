"""
RealFields.py

Contains real magnetic fields derived from the BaseField class
"""

from src.BaseField import BaseField
from scipy.special import ellipk, ellipe
import scipy.constants as sc
import numpy as np
from numpy.typing import ArrayLike, NDArray


class CoilField(BaseField):
    """
    Magnetic field generated by a circular current loop
    """

    def __init__(self, radius, current, Z=0.0):
        """
        Parameters
        ----------
        radius : float
            Radius of coil in metres
        current : float
            Current in amperes
        Z : float
            Position of coil in metres (default 0.0)
        """

        self.radius = radius
        self.current = current
        self.z = Z

    def __central_field(self):
        return self.current * sc.mu_0 / self.radius / 2.0

    def __on_axis_field(self, z):
        return (sc.mu_0 * self.current * self.radius**2 / 2.0 / (self.radius**2 + (z - self.z)**2)**(1.5))

    def evaluate_field(self, x: ArrayLike, y: ArrayLike, z: ArrayLike) -> tuple:
        # Convert inputs to numpy arrays
        x = np.asarray(x)
        y = np.asarray(y)
        z = np.asarray(z)

        x, y, z = np.broadcast_arrays(x, y, z)

        # Radial distance from x axis
        rad = np.sqrt(x**2 + y**2)

        # Initialize output arrays
        b_x = np.zeros_like(x)
        b_y = np.zeros_like(y)
        b_z = np.zeros_like(z)

        # If on-axis
        on_axis_mask = rad / self.radius < 1e-10
        if np.any(on_axis_mask):
            b_z[on_axis_mask] = self.__on_axis_field(z[on_axis_mask])

        off_axis_mask = rad / self.radius >= 1e-10
        if np.any(off_axis_mask):
            x_off = x[off_axis_mask]
            y_off = y[off_axis_mask]
            z_off = z[off_axis_mask]
            rad_off = rad[off_axis_mask]

            # z relative to position of coil
            z_rel = z_off - self.z

            b_central = self.__central_field()
            rad_norm = rad_off / self.radius
            z_norm = z_rel / self.radius
            alpha = (1.0 + rad_norm)**2 + z_norm**2
            root_alpha_pi = np.sqrt(alpha) * np.pi
            beta = 4 * rad_norm / alpha
            int_e = ellipe(beta)
            int_k = ellipk(beta)
            gamma = alpha - 4 * rad_norm

            b_r = b_central * (int_e * ((1.0 + rad_norm**2 + z_norm**2) / gamma)
                               - int_k) / root_alpha_pi * (z_rel / rad)
            b_z_off = b_central * (int_e * ((1.0 - rad_norm**2 - z_norm**2) / gamma)
                                   + int_k) / root_alpha_pi

            # Convert to Cartesian components
            b_x[off_axis_mask] = b_r * x_off / rad_off
            b_y[off_axis_mask] = b_r * y_off / rad_off
            b_z[off_axis_mask] = b_z_off

        if b_x.ndim == 0:
            return b_x.item(), b_y.item(), b_z.item()
        else:
            return b_x, b_y, b_z
