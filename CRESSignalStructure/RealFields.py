"""
RealFields.py

Contains real magnetic fields derived from the BaseField class
"""

from CRESSignalStructure.BaseField import BaseField
from CRESSignalStructure.Particle import Particle
from scipy.special import ellipk, ellipe
from scipy.optimize import brentq
import scipy.constants as sc
import numpy as np
from numpy.typing import ArrayLike, NDArray


class CoilField(BaseField):
    """
    Magnetic field generated by a circular current loop
    """

    def __init__(self, radius, current, Z=0.0):
        """
        Parameters
        ----------
        radius : float
            Radius of coil in metres
        current : float
            Current in amperes
        Z : float
            Position of coil in metres (default 0.0)
        """

        self.radius = radius
        self.current = current
        self.z = Z

    def __central_field(self):
        return self.current * sc.mu_0 / self.radius / 2.0

    def __on_axis_field(self, z):
        return (sc.mu_0 * self.current * self.radius**2 / 2.0 / (self.radius**2 + (z - self.z)**2)**(1.5))

    def evaluate_field(self, x: ArrayLike, y: ArrayLike, z: ArrayLike) -> tuple:
        # Convert inputs to numpy arrays
        x = np.asarray(x)
        y = np.asarray(y)
        z = np.asarray(z)

        x, y, z = np.broadcast_arrays(x, y, z)

        # Radial distance from x axis
        rad = np.sqrt(x**2 + y**2)

        # Initialize output arrays
        b_x = np.zeros_like(x)
        b_y = np.zeros_like(y)
        b_z = np.zeros_like(z)

        # If on-axis
        on_axis_mask = rad / self.radius < 1e-10
        if np.any(on_axis_mask):
            b_z[on_axis_mask] = self.__on_axis_field(z[on_axis_mask])

        off_axis_mask = rad / self.radius >= 1e-10
        if np.any(off_axis_mask):
            x_off = x[off_axis_mask]
            y_off = y[off_axis_mask]
            z_off = z[off_axis_mask]
            rad_off = rad[off_axis_mask]

            # z relative to position of coil
            z_rel = z_off - self.z

            b_central = self.__central_field()
            rad_norm = rad_off / self.radius
            z_norm = z_rel / self.radius
            alpha = (1.0 + rad_norm)**2 + z_norm**2
            root_alpha_pi = np.sqrt(alpha) * np.pi
            beta = 4 * rad_norm / alpha
            int_e = ellipe(beta)
            int_k = ellipk(beta)
            gamma = alpha - 4 * rad_norm

            b_r = b_central * (int_e * ((1.0 + rad_norm**2 + z_norm**2) / gamma)
                               - int_k) / root_alpha_pi * (z_rel / rad_off)
            b_z_off = b_central * (int_e * ((1.0 - rad_norm**2 - z_norm**2) / gamma)
                                   + int_k) / root_alpha_pi

            # Convert to Cartesian components
            b_x[off_axis_mask] = b_r * x_off / rad_off
            b_y[off_axis_mask] = b_r * y_off / rad_off
            b_z[off_axis_mask] = b_z_off

        if b_x.ndim == 0:
            return b_x.item(), b_y.item(), b_z.item()
        else:
            return b_x, b_y, b_z

    def CalcZMax(self, particle: Particle) -> float:
        pa = particle.GetPitchAngle()
        pStart = particle.GetPosition()

        centralField = self.evaluate_field_magnitude(pStart[0], pStart[1], 0.)
        muCentre = centralField / (np.sin(pa)**2)

        def zMaxEqn(z):
            result = 1.0 - muCentre / \
                self.evaluate_field_magnitude(pStart[0], pStart[1], z)
            return result

        # Determine where the bounds of the equation solver should be
        upperZBound = 1.0
        zmax, _ = brentq(zMaxEqn, 0.0, upperZBound, full_output=True)
        return zmax


class BathtubField(BaseField):
    """
    Magnetic field generated by two current loops and a flat background field
    """

    def __init__(self, radius: float, current: float, Z1: float, Z2: float,
                 background=np.zeros(3)):
        """
        Parameters
        ----------
        radius : float
            Radius of current loops in metres
        current : float
            Current of loops in amperes
        Z1 : float
            Position of coil 1
        Z2 : float
            Position of coil 2
        background : NDArray
            Background field 3-vector in tesla
        """

        self.coil1 = CoilField(radius=radius, current=current, Z=Z1)
        self.coil2 = CoilField(radius=radius, current=current, Z=Z2)
        self.background = background

    def evaluate_field(self, x: ArrayLike, y: ArrayLike, z: ArrayLike) -> tuple:
        b_x1, b_y1, b_z1 = self.coil1.evaluate_field(x, y, z)
        b_x2, b_y2, b_z2 = self.coil2.evaluate_field(x, y, z)

        b_x = b_x1 + b_x2
        b_y = b_y1 + b_y2
        b_z = b_z1 + b_z2

        return b_x + self.background[0], b_y + self.background[1], b_z + self.background[2]

    def CalcZMax(self, particle: Particle) -> float:
        pa = particle.GetPitchAngle()
        pStart = particle.GetPosition()

        centralField = self.evaluate_field_magnitude(pStart[0], pStart[1], 0.)
        muCentre = centralField / (np.sin(pa)**2)

        def zMaxEqn(z):
            result = 1.0 - muCentre / \
                self.evaluate_field_magnitude(pStart[0], pStart[1], z)
            return result

        # Determine where the bounds of the equation solver should be
        upperZBound = np.max([self.coil1.z, self.coil2.z])

        zmax, _ = brentq(zMaxEqn, 0.0, upperZBound, full_output=True)
        return zmax


class HarmonicField(BaseField):
    """
    Magnetic field generated by a single current loops and a flat background 
    field. The current loop is located at z = 0.
    """

    def __init__(self, radius: float, current: float, background: float):
        """
        Parameters
        ----------
        radius : float
            Radius of current loops in metres
        current : float
            Current of loops in amperes
        background : float
            Background field magnitude in Tesla
        """

        self.coil = CoilField(radius=radius, current=current, Z=0.0)
        self.background = np.array([0.0, 0.0, -background])

    def evaluate_field(self, x: ArrayLike, y: ArrayLike, z: ArrayLike) -> tuple:
        b_x_coil, b_y_coil, b_z_coil = self.coil.evaluate_field(x, y, z)
        return b_x_coil, b_y_coil, b_z_coil + self.background[2]

    def CalcZMax(self, particle: Particle) -> float:
        pa = particle.GetPitchAngle()
        pStart = particle.GetPosition()

        centralField = self.evaluate_field_magnitude(pStart[0], pStart[1], 0.)
        muCentre = centralField / (np.sin(pa)**2)

        def zMaxEqn(z):
            result = 1.0 - muCentre / \
                self.evaluate_field_magnitude(pStart[0], pStart[1], z)
            return result

        # Determine where the bounds of the equation solver should be
        upperZBound = 1.0
        zmax, _ = brentq(zMaxEqn, 0.0, upperZBound, full_output=True)
        return zmax
